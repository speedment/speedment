/**
 *
 * Copyright (c) 2006-2016, Speedment, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); You may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.speedment.internal.core.code;

import com.speedment.Speedment;
import com.speedment.code.Translator;
import com.speedment.internal.codegen.base.Generator;
import com.speedment.internal.codegen.lang.controller.AutoImports;
import com.speedment.internal.codegen.lang.models.AnnotationUsage;
import com.speedment.internal.codegen.lang.models.ClassOrInterface;
import com.speedment.internal.codegen.lang.models.Constructor;
import com.speedment.internal.codegen.lang.models.Field;
import com.speedment.internal.codegen.lang.models.File;
import com.speedment.internal.codegen.lang.models.Javadoc;
import com.speedment.internal.codegen.lang.models.Type;
import static com.speedment.internal.codegen.lang.models.constants.DefaultAnnotationUsage.GENERATED;
import static com.speedment.internal.codegen.lang.models.constants.DefaultJavadocTag.AUTHOR;
import com.speedment.internal.codegen.lang.models.values.TextValue;
import static com.speedment.internal.core.code.DefaultJavaClassTranslator.CopyConstructorMode.SETTER;
import com.speedment.config.db.Column;
import com.speedment.config.db.Dbms;
import com.speedment.config.Document;
import com.speedment.config.db.ForeignKey;
import com.speedment.config.db.Index;
import com.speedment.config.db.Project;
import com.speedment.config.db.Schema;
import com.speedment.config.db.Table;
import com.speedment.config.db.trait.HasEnabled;
import com.speedment.config.db.trait.HasMainInterface;
import com.speedment.config.db.trait.HasName;
import com.speedment.internal.core.config.BaseDocument;
import com.speedment.internal.core.config.db.ColumnImpl;
import com.speedment.internal.core.config.db.DbmsImpl;
import com.speedment.internal.core.config.db.ForeignKeyImpl;
import com.speedment.internal.core.config.db.IndexImpl;
import com.speedment.internal.core.config.db.ProjectImpl;
import com.speedment.internal.core.config.db.SchemaImpl;
import com.speedment.internal.core.config.db.TableImpl;
import com.speedment.internal.util.JavaLanguageNamer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.stream.Stream;
import com.speedment.stream.MapStream;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.BiFunction;
import java.util.function.Function;
import static com.speedment.internal.util.document.DocumentUtil.relativeName;
import static com.speedment.util.NullUtil.requireNonNulls;
import static java.util.Objects.requireNonNull;

/**
 *
 * @author      pemi
 * @param <DOC> document type.
 * @param <T>   Java type (Interface, Class or Enum) to generate
 */
public abstract class DefaultJavaClassTranslator<DOC extends Document & HasName & HasEnabled & HasMainInterface, T extends ClassOrInterface<T>>
        implements JavaClassTranslator<DOC, T> {

    public static final String GETTER_METHOD_PREFIX = "get",
        SETTER_METHOD_PREFIX = "set",
        JAVADOC_MESSAGE = 
        "\n<p>\nThis file is safe to edit. It will not be overwritten by the " +
        "code generator.",
        GENERATED_JAVADOC_MESSAGE =
        "\n<p>\nThis file has been automatically generated by Speedment. " +
        "Any changes made to it will be overwritten.";

    private final Speedment speedment;
    private final Generator generator;
    private final DOC document;
    private final Function<String, T> mainModelConstructor;
    
    private final JavaLanguageNamer javaLanguageNamer;
    
    private final List<BiConsumer<File, Builder<T>>> listeners;

    protected DefaultJavaClassTranslator(Speedment speedment, Generator generator, DOC document, Function<String, T> constructor) {
        this.speedment            = requireNonNull(speedment);
        this.generator            = requireNonNull(generator);
        this.document             = requireNonNull(document);
        this.mainModelConstructor = requireNonNull(constructor);
        this.javaLanguageNamer    = speedment.getCodeGenerationComponent().javaLanguageNamer();
        this.listeners            = new CopyOnWriteArrayList<>();
    }

    @Override
    public DOC getDocument() {
        return document;
    }

    protected Speedment getSpeedment() {
        return speedment;
    }

    protected AnnotationUsage generated() {
        return GENERATED.set(new TextValue("Speedment"));
    }

    protected abstract String getFileName();

    protected abstract T make(File file);

    protected void finializeFile(File file) {
        // Do nothing
    }

    @Override
    public File get() {
        final File file = File.of(
            baseDirectoryName() + "/" + 
            (isInGeneratedPackage() ? "generated/" : "") + 
            getFileName() + ".java"
        );
        
        final T item = make(file);
        item.set(getJavaDoc());
        file.add(item);
        finializeFile(file);
        file.call(new AutoImports(getCodeGenerator().getDependencyMgr()));
        return file;
    }

    protected abstract String getJavadocRepresentText();

    protected Javadoc getJavaDoc() {
        if (isInGeneratedPackage()) {
            return Javadoc.of(
                getJavadocRepresentText() + 
                " representing an entity (for example, a row) in the " + 
                getDocument().mainInterface().getSimpleName() + 
                " " + relativeName(getDocument(), Project.class) + 
                "." + GENERATED_JAVADOC_MESSAGE
            ).add(AUTHOR.setValue("Speedment"));
        } else {
            return Javadoc.of(
                getJavadocRepresentText() + 
                " representing an entity (for example, a row) in the " + 
                getDocument().mainInterface().getSimpleName() + 
                " " + relativeName(getDocument(), Project.class) + 
                "." + GENERATED_JAVADOC_MESSAGE
            ).add(AUTHOR.setValue("Speedment"));
        }
    }

    @Override
    public Generator getCodeGenerator() {
        return generator;
    }

    protected boolean isInGeneratedPackage() {
        return false;
    }
    
    @Override
    public void onMake(BiConsumer<File, Builder<T>> action) {
        listeners.add(action);
    }

    @Override
    public Stream<BiConsumer<File, Builder<T>>> listeners() {
        return listeners.stream();
    }

    protected final class BuilderImpl implements Translator.Builder<T> {

        private final static String PROJECTS = "projects";
        private final String name;
        private final Map<String, List<BiConsumer<T, Document>>> map;

        // Special for this case
        private final List<BiConsumer<T, ForeignKey>> foreignKeyReferencesThisTableConsumers;

        public BuilderImpl(String name) {
            this.name = requireNonNull(name);
            this.map = new HashMap<>();
            this.foreignKeyReferencesThisTableConsumers = new ArrayList<>();
        }

        @Override
        public <P extends Document, D extends Document> Builder<T> forEvery(String key, BiFunction<P, Map<String, Object>, D> constructor, BiConsumer<T, D> consumer) {
            aquireListAndAdd(key, wrap(consumer, constructor));
            return this;
        }

        @Override
        public BuilderImpl forEveryProject(BiConsumer<T, Project> consumer) {
            aquireListAndAdd(PROJECTS, wrap(consumer, ProjectImpl::new));
            return this;
        }

        @Override
        public BuilderImpl forEveryDbms(BiConsumer<T, Dbms> consumer) {
            aquireListAndAdd(Project.DBMSES, wrap(consumer, DbmsImpl::new));
            return this;
        }

        @Override
        public BuilderImpl forEverySchema(BiConsumer<T, Schema> consumer) {
            aquireListAndAdd(Dbms.SCHEMAS, wrap(consumer, SchemaImpl::new));
            return this;
        }

        @Override
        public BuilderImpl forEveryTable(BiConsumer<T, Table> consumer) {
            aquireListAndAdd(Schema.TABLES, wrap(consumer, TableImpl::new));
            return this;
        }

        @Override
        public BuilderImpl forEveryColumn(BiConsumer<T, Column> consumer) {
            aquireListAndAdd(Table.COLUMNS, wrap(consumer, ColumnImpl::new));
            return this;
        }

        @Override
        public BuilderImpl forEveryIndex(BiConsumer<T, Index> consumer) {
            aquireListAndAdd(Table.INDEXES, wrap(consumer, IndexImpl::new));
            return this;
        }

        @Override
        public BuilderImpl forEveryForeignKey(BiConsumer<T, ForeignKey> consumer) {
            aquireListAndAdd(Table.FOREIGN_KEYS, wrap(consumer, ForeignKeyImpl::new));
            return this;
        }
        
        private <P extends Document, D extends Document> BiConsumer<T, Document> wrap(BiConsumer<T, D> consumer, BiFunction<P, Map<String, Object>, D> constructor) {
            return (t, doc) -> {
                @SuppressWarnings("unchecked")
                final P parent = (P) doc.getParent().orElse(null);
                consumer.accept(t, constructor.apply(parent, doc.getData()));
            };
        }

        @Override
        public BuilderImpl forEveryForeignKeyReferencingThis(BiConsumer<T, ForeignKey> consumer) {
            foreignKeyReferencesThisTableConsumers.add(requireNonNull(consumer));
            return this;
        }

        @SuppressWarnings("unchecked")
        protected void aquireListAndAdd(String key, BiConsumer<T, Document> consumer) {
            aquireList(key).add(requireNonNull((BiConsumer<T, Document>) consumer));
        }

        @SuppressWarnings("unchecked")
        protected <C extends Document> List<BiConsumer<T, C>> aquireList(String key) {
            return (List<BiConsumer<T, C>>) (List<?>) map.computeIfAbsent(key, $ -> new CopyOnWriteArrayList<>());
        }

        public <D extends Document & HasMainInterface> void act(String key, T item, D document) {
            aquireList(key).forEach(c -> 
                c.accept(requireNonNull(item), requireNonNull(document))
            );
        }

        @Override
        public T build() {
            final T i = mainModelConstructor.apply(name);
            act(PROJECTS, i, project());
            act(Project.DBMSES, i, dbms());
            act(Dbms.SCHEMAS, i, schema());
            act(Schema.TABLES, i, table());

            MapStream.of(map)
                .flatMapValue(List::stream)
                .forEachOrdered((key, actor) -> 
                    table().childrenByKey()
                        .filterKey(key::equals)
                        .values()
                        .map(data -> new BaseDocument(table(), data))
                        .filter(HasEnabled::test)
                        .forEachOrdered(c -> actor.accept(i, c))
                );

            if (Table.class.equals(getDocument().mainInterface())) {
                schema().tables()
                    .filter(HasEnabled::test)
                    .flatMap(t -> t.foreignKeys())
                    .filter(fk -> fk.foreignKeyColumns()
                        .filter(fkc -> fkc.getForeignTableName().equals(getDocument().getName()))
                        .findFirst()
                        .isPresent()
                    )
                    .forEachOrdered(fk
                        -> foreignKeyReferencesThisTableConsumers.forEach(
                            c -> c.accept(i, fk)
                        )
                    );
            }

            i.add(generated());
            return i;
        }
    }
    
    protected final Builder<T> newBuilder(File file, String className) {
        requireNonNulls(file, className);
        final Builder<T> builder = new BuilderImpl(className);
        listeners().forEachOrdered(action -> action.accept(file, builder));
        return builder;
    }

    public Field fieldFor(Column c) {
        return Field.of(variableName(c), Type.of(c.findTypeMapper().getJavaType()));
    }

    public Constructor emptyConstructor() {
        return Constructor.of().public_();
    }

    public enum CopyConstructorMode {
        SETTER, FIELD;
    }

    public Constructor copyConstructor(Type type, CopyConstructorMode mode) {
        final Constructor constructor = Constructor.of().protected_()
            .add(Field.of(variableName(), type));

        columns().forEachOrdered(c -> {
            switch (mode) {
                case FIELD: {
                    constructor.add("this." + variableName(c) + " = " + variableName() + "." + GETTER_METHOD_PREFIX + typeName(c) + "();");
                    break;
                }
                case SETTER: {
                    if (c.isNullable()) {
                        constructor.add(
                                variableName() + "."
                                + GETTER_METHOD_PREFIX + typeName(c)
                                + "().ifPresent(this::"
                                + SETTER_METHOD_PREFIX + typeName(c)
                                + ");"
                        );
                    } else {
                        constructor.add(
                                SETTER_METHOD_PREFIX + typeName(c)
                                + "(" + variableName()
                                + ".get" + typeName(c)
                                + "());"
                        );
                    }
                    break;
                }
                default: throw new UnsupportedOperationException(
                    "Unknown mode '" + mode + "'."
                );
            }
        });

        return constructor;
    }

    @Override
    public JavaLanguageNamer javaLanguageNamer() {
        return javaLanguageNamer;
    }

}
